// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `dto_to_proxy_config`, `proxy_config_to_dto`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `from`, `from`

/// Load the current proxy configuration from the runtime state.
Future<ProxyConfigDto> getProxyConfig() =>
    RustLib.instance.api.crateApiProxyApiGetProxyConfig();

/// Update the proxy configuration in-memory and apply it to the runtime
/// immediately (all future reqwest clients will use the new settings).
/// Returns "ok" on success or an error string.
Future<String> updateProxyConfig({required ProxyConfigDto config}) =>
    RustLib.instance.api.crateApiProxyApiUpdateProxyConfig(config: config);

/// Save the current proxy configuration to disk (~/.zeroclaw/config.toml).
/// This is called separately from update so the user can test settings
/// before persisting.
Future<String> saveProxyToDisk() =>
    RustLib.instance.api.crateApiProxyApiSaveProxyToDisk();

/// List supported service keys for scope = Services.
List<ProxyServiceInfo> listProxyServices() =>
    RustLib.instance.api.crateApiProxyApiListProxyServices();

/// Quick test: validate a proxy URL without persisting anything.
String validateProxyUrl({required String url}) =>
    RustLib.instance.api.crateApiProxyApiValidateProxyUrl(url: url);

/// Proxy configuration exposed to Flutter.
class ProxyConfigDto {
  /// Whether proxy support is enabled.
  final bool enabled;

  /// Proxy URL for HTTP requests (http, https, socks5, socks5h).
  final String httpProxy;

  /// Proxy URL for HTTPS requests.
  final String httpsProxy;

  /// Fallback proxy URL for all schemes.
  final String allProxy;

  /// No-proxy bypass list (comma-separated).
  final String noProxy;

  /// Proxy application scope.
  final ProxyScopeDto scope;

  /// Service selectors (used when scope = Services), comma-separated.
  final String services;

  const ProxyConfigDto({
    required this.enabled,
    required this.httpProxy,
    required this.httpsProxy,
    required this.allProxy,
    required this.noProxy,
    required this.scope,
    required this.services,
  });

  static Future<ProxyConfigDto> default_() =>
      RustLib.instance.api.crateApiProxyApiProxyConfigDtoDefault();

  @override
  int get hashCode =>
      enabled.hashCode ^
      httpProxy.hashCode ^
      httpsProxy.hashCode ^
      allProxy.hashCode ^
      noProxy.hashCode ^
      scope.hashCode ^
      services.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ProxyConfigDto &&
          runtimeType == other.runtimeType &&
          enabled == other.enabled &&
          httpProxy == other.httpProxy &&
          httpsProxy == other.httpsProxy &&
          allProxy == other.allProxy &&
          noProxy == other.noProxy &&
          scope == other.scope &&
          services == other.services;
}

/// Proxy scope â€” determines which outbound traffic uses the proxy.
enum ProxyScopeDto {
  /// Use system environment proxy variables only.
  environment,

  /// Apply proxy to all ZeroClaw-managed HTTP traffic (default).
  zeroclaw,

  /// Apply proxy only to explicitly listed service selectors.
  services,
}

/// Supported service keys that can be used with scope = Services.
class ProxyServiceInfo {
  final String key;
  final String category;

  const ProxyServiceInfo({required this.key, required this.category});

  @override
  int get hashCode => key.hashCode ^ category.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ProxyServiceInfo &&
          runtimeType == other.runtimeType &&
          key == other.key &&
          category == other.category;
}
