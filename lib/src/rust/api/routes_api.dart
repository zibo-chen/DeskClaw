// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`

/// List all configured model routes
Future<List<ModelRouteDto>> listModelRoutes() =>
    RustLib.instance.api.crateApiRoutesApiListModelRoutes();

/// Create or update a model route by hint. Returns "ok" on success.
Future<String> upsertModelRoute({required ModelRouteDto route}) =>
    RustLib.instance.api.crateApiRoutesApiUpsertModelRoute(route: route);

/// Remove a model route by hint. Returns "ok" on success.
Future<String> removeModelRoute({required String hint}) =>
    RustLib.instance.api.crateApiRoutesApiRemoveModelRoute(hint: hint);

/// List all configured embedding routes
Future<List<EmbeddingRouteDto>> listEmbeddingRoutes() =>
    RustLib.instance.api.crateApiRoutesApiListEmbeddingRoutes();

/// Create or update an embedding route by hint. Returns "ok" on success.
Future<String> upsertEmbeddingRoute({required EmbeddingRouteDto route}) =>
    RustLib.instance.api.crateApiRoutesApiUpsertEmbeddingRoute(route: route);

/// Remove an embedding route by hint. Returns "ok" on success.
Future<String> removeEmbeddingRoute({required String hint}) =>
    RustLib.instance.api.crateApiRoutesApiRemoveEmbeddingRoute(hint: hint);

/// Get current embedding configuration
Future<EmbeddingConfigDto> getEmbeddingConfig() =>
    RustLib.instance.api.crateApiRoutesApiGetEmbeddingConfig();

/// Update embedding configuration. Returns "ok" on success.
Future<String> updateEmbeddingConfig({required EmbeddingConfigDto config}) =>
    RustLib.instance.api.crateApiRoutesApiUpdateEmbeddingConfig(config: config);

/// Embedding configuration for semantic search and memory recall
class EmbeddingConfigDto {
  final String embeddingProvider;
  final String embeddingModel;
  final int embeddingDimensions;
  final double vectorWeight;
  final double keywordWeight;
  final double minRelevanceScore;

  const EmbeddingConfigDto({
    required this.embeddingProvider,
    required this.embeddingModel,
    required this.embeddingDimensions,
    required this.vectorWeight,
    required this.keywordWeight,
    required this.minRelevanceScore,
  });

  @override
  int get hashCode =>
      embeddingProvider.hashCode ^
      embeddingModel.hashCode ^
      embeddingDimensions.hashCode ^
      vectorWeight.hashCode ^
      keywordWeight.hashCode ^
      minRelevanceScore.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is EmbeddingConfigDto &&
          runtimeType == other.runtimeType &&
          embeddingProvider == other.embeddingProvider &&
          embeddingModel == other.embeddingModel &&
          embeddingDimensions == other.embeddingDimensions &&
          vectorWeight == other.vectorWeight &&
          keywordWeight == other.keywordWeight &&
          minRelevanceScore == other.minRelevanceScore;
}

/// Embedding route DTO — route an embedding hint to a specific provider + model
class EmbeddingRouteDto {
  final String hint;
  final String provider;
  final String model;
  final int? dimensions;
  final String? apiKey;

  const EmbeddingRouteDto({
    required this.hint,
    required this.provider,
    required this.model,
    this.dimensions,
    this.apiKey,
  });

  @override
  int get hashCode =>
      hint.hashCode ^
      provider.hashCode ^
      model.hashCode ^
      dimensions.hashCode ^
      apiKey.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is EmbeddingRouteDto &&
          runtimeType == other.runtimeType &&
          hint == other.hint &&
          provider == other.provider &&
          model == other.model &&
          dimensions == other.dimensions &&
          apiKey == other.apiKey;
}

/// Model route DTO — route a task hint to a specific provider + model
class ModelRouteDto {
  final String hint;
  final String provider;
  final String model;
  final String? apiKey;

  const ModelRouteDto({
    required this.hint,
    required this.provider,
    required this.model,
    this.apiKey,
  });

  @override
  int get hashCode =>
      hint.hashCode ^ provider.hashCode ^ model.hashCode ^ apiKey.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ModelRouteDto &&
          runtimeType == other.runtimeType &&
          hint == other.hint &&
          provider == other.provider &&
          model == other.model &&
          apiKey == other.apiKey;
}
