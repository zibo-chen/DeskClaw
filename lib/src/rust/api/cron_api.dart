// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `build_schedule_json`, `compute_next_run`, `db_path`, `decode_schedule_info`, `format_interval`, `open_db`, `parse_rfc3339_to_ts`, `row_to_dto`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`

/// Get cron system configuration and stats
Future<CronConfigDto> getCronConfig() =>
    RustLib.instance.api.crateApiCronApiGetCronConfig();

/// List all cron jobs
Future<List<CronJobDto>> listCronJobs() =>
    RustLib.instance.api.crateApiCronApiListCronJobs();

/// Add a new shell cron job
Future<String> addShellCronJob({
  String? name,
  required String scheduleType,
  required String expression,
  required String command,
}) => RustLib.instance.api.crateApiCronApiAddShellCronJob(
  name: name,
  scheduleType: scheduleType,
  expression: expression,
  command: command,
);

/// Add a new agent cron job
Future<String> addAgentCronJob({
  String? name,
  required String scheduleType,
  required String expression,
  required String prompt,
  required String sessionTarget,
  String? model,
  required bool deleteAfterRun,
}) => RustLib.instance.api.crateApiCronApiAddAgentCronJob(
  name: name,
  scheduleType: scheduleType,
  expression: expression,
  prompt: prompt,
  sessionTarget: sessionTarget,
  model: model,
  deleteAfterRun: deleteAfterRun,
);

/// Remove a cron job
Future<String> removeCronJob({required String jobId}) =>
    RustLib.instance.api.crateApiCronApiRemoveCronJob(jobId: jobId);

/// Pause a cron job
Future<String> pauseCronJob({required String jobId}) =>
    RustLib.instance.api.crateApiCronApiPauseCronJob(jobId: jobId);

/// Resume a cron job
Future<String> resumeCronJob({required String jobId}) =>
    RustLib.instance.api.crateApiCronApiResumeCronJob(jobId: jobId);

/// Get run history for a specific job
Future<List<CronRunDto>> listCronRuns({
  required String jobId,
  required int limit,
}) => RustLib.instance.api.crateApiCronApiListCronRuns(
  jobId: jobId,
  limit: limit,
);

/// Update a cron job
Future<String> updateCronJob({
  required String jobId,
  String? name,
  String? scheduleType,
  String? expression,
  String? command,
  String? prompt,
  bool? enabled,
}) => RustLib.instance.api.crateApiCronApiUpdateCronJob(
  jobId: jobId,
  name: name,
  scheduleType: scheduleType,
  expression: expression,
  command: command,
  prompt: prompt,
  enabled: enabled,
);

/// Cron system configuration
class CronConfigDto {
  final bool enabled;
  final int maxRunHistory;
  final int totalJobs;
  final int activeJobs;
  final int pausedJobs;

  const CronConfigDto({
    required this.enabled,
    required this.maxRunHistory,
    required this.totalJobs,
    required this.activeJobs,
    required this.pausedJobs,
  });

  @override
  int get hashCode =>
      enabled.hashCode ^
      maxRunHistory.hashCode ^
      totalJobs.hashCode ^
      activeJobs.hashCode ^
      pausedJobs.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CronConfigDto &&
          runtimeType == other.runtimeType &&
          enabled == other.enabled &&
          maxRunHistory == other.maxRunHistory &&
          totalJobs == other.totalJobs &&
          activeJobs == other.activeJobs &&
          pausedJobs == other.pausedJobs;
}

/// Cron job summary for UI display
class CronJobDto {
  final String id;
  final String name;
  final String expression;
  final String scheduleType;
  final String scheduleDisplay;
  final String command;
  final String prompt;
  final String jobType;
  final String sessionTarget;
  final String model;
  final bool enabled;
  final bool deleteAfterRun;
  final PlatformInt64 createdAt;
  final PlatformInt64 nextRun;
  final PlatformInt64? lastRun;
  final String lastStatus;
  final String lastOutput;

  const CronJobDto({
    required this.id,
    required this.name,
    required this.expression,
    required this.scheduleType,
    required this.scheduleDisplay,
    required this.command,
    required this.prompt,
    required this.jobType,
    required this.sessionTarget,
    required this.model,
    required this.enabled,
    required this.deleteAfterRun,
    required this.createdAt,
    required this.nextRun,
    this.lastRun,
    required this.lastStatus,
    required this.lastOutput,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      name.hashCode ^
      expression.hashCode ^
      scheduleType.hashCode ^
      scheduleDisplay.hashCode ^
      command.hashCode ^
      prompt.hashCode ^
      jobType.hashCode ^
      sessionTarget.hashCode ^
      model.hashCode ^
      enabled.hashCode ^
      deleteAfterRun.hashCode ^
      createdAt.hashCode ^
      nextRun.hashCode ^
      lastRun.hashCode ^
      lastStatus.hashCode ^
      lastOutput.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CronJobDto &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          name == other.name &&
          expression == other.expression &&
          scheduleType == other.scheduleType &&
          scheduleDisplay == other.scheduleDisplay &&
          command == other.command &&
          prompt == other.prompt &&
          jobType == other.jobType &&
          sessionTarget == other.sessionTarget &&
          model == other.model &&
          enabled == other.enabled &&
          deleteAfterRun == other.deleteAfterRun &&
          createdAt == other.createdAt &&
          nextRun == other.nextRun &&
          lastRun == other.lastRun &&
          lastStatus == other.lastStatus &&
          lastOutput == other.lastOutput;
}

/// Cron run history entry
class CronRunDto {
  final PlatformInt64 id;
  final String jobId;
  final PlatformInt64 startedAt;
  final PlatformInt64 finishedAt;
  final String status;
  final String output;
  final PlatformInt64 durationMs;

  const CronRunDto({
    required this.id,
    required this.jobId,
    required this.startedAt,
    required this.finishedAt,
    required this.status,
    required this.output,
    required this.durationMs,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      jobId.hashCode ^
      startedAt.hashCode ^
      finishedAt.hashCode ^
      status.hashCode ^
      output.hashCode ^
      durationMs.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CronRunDto &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          jobId == other.jobId &&
          startedAt == other.startedAt &&
          finishedAt == other.finishedAt &&
          status == other.status &&
          output == other.output &&
          durationMs == other.durationMs;
}
