// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `json_str_array`, `json_value_to_toml`, `save_channel_config_to_disk`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `ChannelConfigField`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`

/// Get workspace configuration
Future<WorkspaceConfig> getWorkspaceConfig() =>
    RustLib.instance.api.crateApiWorkspaceApiGetWorkspaceConfig();

/// Get autonomy settings
Future<AutonomyConfig> getAutonomyConfig() =>
    RustLib.instance.api.crateApiWorkspaceApiGetAutonomyConfig();

/// Update autonomy level
Future<String> updateAutonomyLevel({required String level}) =>
    RustLib.instance.api.crateApiWorkspaceApiUpdateAutonomyLevel(level: level);

/// Get agent config
Future<AgentConfigDto> getAgentConfig() =>
    RustLib.instance.api.crateApiWorkspaceApiGetAgentConfig();

/// Update agent settings
Future<String> updateAgentConfig({
  int? maxToolIterations,
  int? maxHistoryMessages,
  bool? parallelTools,
  bool? compactContext,
}) => RustLib.instance.api.crateApiWorkspaceApiUpdateAgentConfig(
  maxToolIterations: maxToolIterations,
  maxHistoryMessages: maxHistoryMessages,
  parallelTools: parallelTools,
  compactContext: compactContext,
);

/// Get memory configuration
Future<MemoryConfigDto> getMemoryConfig() =>
    RustLib.instance.api.crateApiWorkspaceApiGetMemoryConfig();

/// Get cost configuration
Future<CostConfigDto> getCostConfig() =>
    RustLib.instance.api.crateApiWorkspaceApiGetCostConfig();

/// List configured channels with their enabled status
Future<List<ChannelSummary>> listChannels() =>
    RustLib.instance.api.crateApiWorkspaceApiListChannels();

/// List tools with their approval status based on autonomy config
Future<List<ToolInfo>> listToolsWithStatus() =>
    RustLib.instance.api.crateApiWorkspaceApiListToolsWithStatus();

/// Toggle a tool's approval status: "auto", "ask", or "default"
Future<String> setToolApproval({
  required String toolName,
  required String approval,
}) => RustLib.instance.api.crateApiWorkspaceApiSetToolApproval(
  toolName: toolName,
  approval: approval,
);

/// Batch update tool approvals: set multiple tools at once
Future<String> batchSetToolApprovals({
  required List<String> autoApprove,
  required List<String> alwaysAsk,
}) => RustLib.instance.api.crateApiWorkspaceApiBatchSetToolApprovals(
  autoApprove: autoApprove,
  alwaysAsk: alwaysAsk,
);

/// Get feature toggles for quick configuration
Future<FeatureToggles> getFeatureToggles() =>
    RustLib.instance.api.crateApiWorkspaceApiGetFeatureToggles();

/// Update a single feature toggle
Future<String> updateFeatureToggle({
  required String feature,
  required bool enabled,
}) => RustLib.instance.api.crateApiWorkspaceApiUpdateFeatureToggle(
  feature: feature,
  enabled: enabled,
);

/// Get channel configuration fields (returns JSON string for flexibility)
Future<String> getChannelConfig({required String channelType}) => RustLib
    .instance
    .api
    .crateApiWorkspaceApiGetChannelConfig(channelType: channelType);

/// Save channel configuration from JSON string
Future<String> saveChannelConfig({
  required String channelType,
  required String configJson,
}) => RustLib.instance.api.crateApiWorkspaceApiSaveChannelConfig(
  channelType: channelType,
  configJson: configJson,
);

/// Toggle a channel on/off. If disabling, removes config. If enabling, needs save_channel_config.
Future<String> toggleChannel({
  required String channelType,
  required bool enabled,
}) => RustLib.instance.api.crateApiWorkspaceApiToggleChannel(
  channelType: channelType,
  enabled: enabled,
);

/// Agent config DTO
class AgentConfigDto {
  final int maxToolIterations;
  final int maxHistoryMessages;
  final bool parallelTools;
  final String toolDispatcher;
  final bool compactContext;

  const AgentConfigDto({
    required this.maxToolIterations,
    required this.maxHistoryMessages,
    required this.parallelTools,
    required this.toolDispatcher,
    required this.compactContext,
  });

  @override
  int get hashCode =>
      maxToolIterations.hashCode ^
      maxHistoryMessages.hashCode ^
      parallelTools.hashCode ^
      toolDispatcher.hashCode ^
      compactContext.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AgentConfigDto &&
          runtimeType == other.runtimeType &&
          maxToolIterations == other.maxToolIterations &&
          maxHistoryMessages == other.maxHistoryMessages &&
          parallelTools == other.parallelTools &&
          toolDispatcher == other.toolDispatcher &&
          compactContext == other.compactContext;
}

/// Autonomy configuration DTO
class AutonomyConfig {
  final String level;
  final bool workspaceOnly;
  final List<String> allowedCommands;
  final List<String> forbiddenPaths;
  final int maxActionsPerHour;
  final int maxCostPerDayCents;
  final bool requireApprovalForMediumRisk;
  final bool blockHighRiskCommands;
  final List<String> autoApprove;
  final List<String> alwaysAsk;

  const AutonomyConfig({
    required this.level,
    required this.workspaceOnly,
    required this.allowedCommands,
    required this.forbiddenPaths,
    required this.maxActionsPerHour,
    required this.maxCostPerDayCents,
    required this.requireApprovalForMediumRisk,
    required this.blockHighRiskCommands,
    required this.autoApprove,
    required this.alwaysAsk,
  });

  @override
  int get hashCode =>
      level.hashCode ^
      workspaceOnly.hashCode ^
      allowedCommands.hashCode ^
      forbiddenPaths.hashCode ^
      maxActionsPerHour.hashCode ^
      maxCostPerDayCents.hashCode ^
      requireApprovalForMediumRisk.hashCode ^
      blockHighRiskCommands.hashCode ^
      autoApprove.hashCode ^
      alwaysAsk.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AutonomyConfig &&
          runtimeType == other.runtimeType &&
          level == other.level &&
          workspaceOnly == other.workspaceOnly &&
          allowedCommands == other.allowedCommands &&
          forbiddenPaths == other.forbiddenPaths &&
          maxActionsPerHour == other.maxActionsPerHour &&
          maxCostPerDayCents == other.maxCostPerDayCents &&
          requireApprovalForMediumRisk == other.requireApprovalForMediumRisk &&
          blockHighRiskCommands == other.blockHighRiskCommands &&
          autoApprove == other.autoApprove &&
          alwaysAsk == other.alwaysAsk;
}

/// Channel summary for listing in UI
class ChannelSummary {
  final String id;
  final String name;
  final String channelType;
  final bool enabled;
  final String description;

  const ChannelSummary({
    required this.id,
    required this.name,
    required this.channelType,
    required this.enabled,
    required this.description,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      name.hashCode ^
      channelType.hashCode ^
      enabled.hashCode ^
      description.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ChannelSummary &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          name == other.name &&
          channelType == other.channelType &&
          enabled == other.enabled &&
          description == other.description;
}

/// Cost config DTO
class CostConfigDto {
  final bool enabled;
  final double dailyLimitUsd;
  final double monthlyLimitUsd;
  final int warnAtPercent;

  const CostConfigDto({
    required this.enabled,
    required this.dailyLimitUsd,
    required this.monthlyLimitUsd,
    required this.warnAtPercent,
  });

  @override
  int get hashCode =>
      enabled.hashCode ^
      dailyLimitUsd.hashCode ^
      monthlyLimitUsd.hashCode ^
      warnAtPercent.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CostConfigDto &&
          runtimeType == other.runtimeType &&
          enabled == other.enabled &&
          dailyLimitUsd == other.dailyLimitUsd &&
          monthlyLimitUsd == other.monthlyLimitUsd &&
          warnAtPercent == other.warnAtPercent;
}

/// Feature toggle state for quick configuration
class FeatureToggles {
  final bool webSearchEnabled;
  final bool webFetchEnabled;
  final bool browserEnabled;
  final bool httpRequestEnabled;
  final bool memoryAutoSave;
  final bool costTrackingEnabled;
  final bool skillsOpenEnabled;

  const FeatureToggles({
    required this.webSearchEnabled,
    required this.webFetchEnabled,
    required this.browserEnabled,
    required this.httpRequestEnabled,
    required this.memoryAutoSave,
    required this.costTrackingEnabled,
    required this.skillsOpenEnabled,
  });

  static Future<FeatureToggles> default_() =>
      RustLib.instance.api.crateApiWorkspaceApiFeatureTogglesDefault();

  @override
  int get hashCode =>
      webSearchEnabled.hashCode ^
      webFetchEnabled.hashCode ^
      browserEnabled.hashCode ^
      httpRequestEnabled.hashCode ^
      memoryAutoSave.hashCode ^
      costTrackingEnabled.hashCode ^
      skillsOpenEnabled.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FeatureToggles &&
          runtimeType == other.runtimeType &&
          webSearchEnabled == other.webSearchEnabled &&
          webFetchEnabled == other.webFetchEnabled &&
          browserEnabled == other.browserEnabled &&
          httpRequestEnabled == other.httpRequestEnabled &&
          memoryAutoSave == other.memoryAutoSave &&
          costTrackingEnabled == other.costTrackingEnabled &&
          skillsOpenEnabled == other.skillsOpenEnabled;
}

/// Memory config DTO
class MemoryConfigDto {
  final String backend;
  final bool autoSave;
  final bool hygieneEnabled;
  final int archiveAfterDays;
  final int purgeAfterDays;
  final int conversationRetentionDays;
  final String embeddingProvider;
  final String embeddingModel;

  const MemoryConfigDto({
    required this.backend,
    required this.autoSave,
    required this.hygieneEnabled,
    required this.archiveAfterDays,
    required this.purgeAfterDays,
    required this.conversationRetentionDays,
    required this.embeddingProvider,
    required this.embeddingModel,
  });

  @override
  int get hashCode =>
      backend.hashCode ^
      autoSave.hashCode ^
      hygieneEnabled.hashCode ^
      archiveAfterDays.hashCode ^
      purgeAfterDays.hashCode ^
      conversationRetentionDays.hashCode ^
      embeddingProvider.hashCode ^
      embeddingModel.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MemoryConfigDto &&
          runtimeType == other.runtimeType &&
          backend == other.backend &&
          autoSave == other.autoSave &&
          hygieneEnabled == other.hygieneEnabled &&
          archiveAfterDays == other.archiveAfterDays &&
          purgeAfterDays == other.purgeAfterDays &&
          conversationRetentionDays == other.conversationRetentionDays &&
          embeddingProvider == other.embeddingProvider &&
          embeddingModel == other.embeddingModel;
}

/// Tool info with security attributes
class ToolInfo {
  final String name;
  final String description;
  final String category;
  final bool autoApproved;
  final bool alwaysAsk;

  const ToolInfo({
    required this.name,
    required this.description,
    required this.category,
    required this.autoApproved,
    required this.alwaysAsk,
  });

  @override
  int get hashCode =>
      name.hashCode ^
      description.hashCode ^
      category.hashCode ^
      autoApproved.hashCode ^
      alwaysAsk.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ToolInfo &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          description == other.description &&
          category == other.category &&
          autoApproved == other.autoApproved &&
          alwaysAsk == other.alwaysAsk;
}

/// Workspace configuration DTO
class WorkspaceConfig {
  final String workspaceDir;
  final String configPath;

  const WorkspaceConfig({required this.workspaceDir, required this.configPath});

  @override
  int get hashCode => workspaceDir.hashCode ^ configPath.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WorkspaceConfig &&
          runtimeType == other.runtimeType &&
          workspaceDir == other.workspaceDir &&
          configPath == other.configPath;
}
