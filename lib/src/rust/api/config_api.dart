// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`

/// Get the list of available providers with their supported models
List<ProviderInfo> listProviders() =>
    RustLib.instance.api.crateApiConfigApiListProviders();

/// Load config from the zeroclaw runtime state
Future<AppConfig> loadConfig() =>
    RustLib.instance.api.crateApiConfigApiLoadConfig();

/// Save config â€” updates runtime state and persists to disk
Future<bool> saveConfig({required AppConfig config}) =>
    RustLib.instance.api.crateApiConfigApiSaveConfig(config: config);

/// Application configuration exposed to Flutter
class AppConfig {
  final String provider;
  final String model;
  final String apiKey;
  final String? apiBase;
  final double temperature;
  final int maxToolIterations;
  final String language;

  const AppConfig({
    required this.provider,
    required this.model,
    required this.apiKey,
    this.apiBase,
    required this.temperature,
    required this.maxToolIterations,
    required this.language,
  });

  static Future<AppConfig> default_() =>
      RustLib.instance.api.crateApiConfigApiAppConfigDefault();

  @override
  int get hashCode =>
      provider.hashCode ^
      model.hashCode ^
      apiKey.hashCode ^
      apiBase.hashCode ^
      temperature.hashCode ^
      maxToolIterations.hashCode ^
      language.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AppConfig &&
          runtimeType == other.runtimeType &&
          provider == other.provider &&
          model == other.model &&
          apiKey == other.apiKey &&
          apiBase == other.apiBase &&
          temperature == other.temperature &&
          maxToolIterations == other.maxToolIterations &&
          language == other.language;
}

/// Provider info for display in UI
class ProviderInfo {
  final String id;
  final String name;
  final ProviderType providerType;
  final List<String> models;
  final bool requiresApiKey;
  final bool requiresApiBase;

  const ProviderInfo({
    required this.id,
    required this.name,
    required this.providerType,
    required this.models,
    required this.requiresApiKey,
    required this.requiresApiBase,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      name.hashCode ^
      providerType.hashCode ^
      models.hashCode ^
      requiresApiKey.hashCode ^
      requiresApiBase.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ProviderInfo &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          name == other.name &&
          providerType == other.providerType &&
          models == other.models &&
          requiresApiKey == other.requiresApiKey &&
          requiresApiBase == other.requiresApiBase;
}

/// Supported LLM provider types
enum ProviderType {
  openAi,
  anthropic,
  gemini,
  ollama,
  openRouter,
  compatible,
  bedrock,
  copilot,
  telnyx,
  glm,
}
