// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `category_to_string`, `ensure_memory_backend`, `entry_to_dto`, `memory_backend`, `parse_category`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `fmt`, `fmt`

/// Get knowledge base statistics
Future<KnowledgeStats> getKnowledgeStats() =>
    RustLib.instance.api.crateApiKnowledgeApiGetKnowledgeStats();

/// List knowledge entries, optionally filtered by category
Future<List<KnowledgeEntry>> listKnowledgeEntries({
  String? category,
  required int limit,
}) => RustLib.instance.api.crateApiKnowledgeApiListKnowledgeEntries(
  category: category,
  limit: limit,
);

/// Search knowledge entries by query (semantic search if embeddings available, otherwise keyword)
Future<List<KnowledgeEntry>> searchKnowledge({
  required String query,
  required int limit,
}) => RustLib.instance.api.crateApiKnowledgeApiSearchKnowledge(
  query: query,
  limit: limit,
);

/// Add a new knowledge entry
Future<String> addKnowledgeEntry({
  required String key,
  required String content,
  required String category,
}) => RustLib.instance.api.crateApiKnowledgeApiAddKnowledgeEntry(
  key: key,
  content: content,
  category: category,
);

/// Delete a knowledge entry by key
Future<String> deleteKnowledgeEntry({required String key}) =>
    RustLib.instance.api.crateApiKnowledgeApiDeleteKnowledgeEntry(key: key);

/// Get a single knowledge entry by key
Future<KnowledgeEntry?> getKnowledgeEntry({required String key}) =>
    RustLib.instance.api.crateApiKnowledgeApiGetKnowledgeEntry(key: key);

/// A memory/knowledge entry for display in the GUI
class KnowledgeEntry {
  final String id;
  final String key;
  final String content;
  final String category;
  final String timestamp;
  final String sessionId;
  final double score;

  const KnowledgeEntry({
    required this.id,
    required this.key,
    required this.content,
    required this.category,
    required this.timestamp,
    required this.sessionId,
    required this.score,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      key.hashCode ^
      content.hashCode ^
      category.hashCode ^
      timestamp.hashCode ^
      sessionId.hashCode ^
      score.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is KnowledgeEntry &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          key == other.key &&
          content == other.content &&
          category == other.category &&
          timestamp == other.timestamp &&
          sessionId == other.sessionId &&
          score == other.score;
}

/// Knowledge base statistics
class KnowledgeStats {
  final int totalEntries;
  final String backend;
  final bool healthy;
  final String embeddingProvider;
  final String embeddingModel;
  final bool autoSave;

  const KnowledgeStats({
    required this.totalEntries,
    required this.backend,
    required this.healthy,
    required this.embeddingProvider,
    required this.embeddingModel,
    required this.autoSave,
  });

  @override
  int get hashCode =>
      totalEntries.hashCode ^
      backend.hashCode ^
      healthy.hashCode ^
      embeddingProvider.hashCode ^
      embeddingModel.hashCode ^
      autoSave.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is KnowledgeStats &&
          runtimeType == other.runtimeType &&
          totalEntries == other.totalEntries &&
          backend == other.backend &&
          healthy == other.healthy &&
          embeddingProvider == other.embeddingProvider &&
          embeddingModel == other.embeddingModel &&
          autoSave == other.autoSave;
}
