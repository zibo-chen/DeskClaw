// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `persist_to_disk`, `session_store`, `sessions_file_path`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `PersistedMessage`, `PersistedSession`, `SessionStore`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`
// These functions are ignored (category: IgnoreBecauseOwnerTyShouldIgnore): `default`

/// Initialize session store â€” load from disk
Future<String> initSessionStore() =>
    RustLib.instance.api.crateApiSessionsApiInitSessionStore();

/// List all sessions (without full messages)
Future<List<SessionSummary>> listSessions() =>
    RustLib.instance.api.crateApiSessionsApiListSessions();

/// Get full session detail including messages
Future<SessionDetail?> getSessionDetail({required String sessionId}) => RustLib
    .instance
    .api
    .crateApiSessionsApiGetSessionDetail(sessionId: sessionId);

/// Save/update a session with its messages
Future<String> saveSession({
  required String sessionId,
  required String title,
  required List<SessionMessage> messages,
}) => RustLib.instance.api.crateApiSessionsApiSaveSession(
  sessionId: sessionId,
  title: title,
  messages: messages,
);

/// Delete a session
Future<String> deleteSession({required String sessionId}) =>
    RustLib.instance.api.crateApiSessionsApiDeleteSession(sessionId: sessionId);

/// Rename a session
Future<String> renameSession({
  required String sessionId,
  required String newTitle,
}) => RustLib.instance.api.crateApiSessionsApiRenameSession(
  sessionId: sessionId,
  newTitle: newTitle,
);

/// Get session statistics
Future<SessionStats> getSessionStats() =>
    RustLib.instance.api.crateApiSessionsApiGetSessionStats();

/// Clear all sessions
Future<String> clearAllSessions() =>
    RustLib.instance.api.crateApiSessionsApiClearAllSessions();

/// A persisted chat session with messages
class SessionDetail {
  final String id;
  final String title;
  final PlatformInt64 createdAt;
  final PlatformInt64 updatedAt;
  final int messageCount;
  final List<SessionMessage> messages;

  const SessionDetail({
    required this.id,
    required this.title,
    required this.createdAt,
    required this.updatedAt,
    required this.messageCount,
    required this.messages,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      title.hashCode ^
      createdAt.hashCode ^
      updatedAt.hashCode ^
      messageCount.hashCode ^
      messages.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SessionDetail &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          title == other.title &&
          createdAt == other.createdAt &&
          updatedAt == other.updatedAt &&
          messageCount == other.messageCount &&
          messages == other.messages;
}

/// A message within a session
class SessionMessage {
  final String id;
  final String role;
  final String content;
  final PlatformInt64 timestamp;

  const SessionMessage({
    required this.id,
    required this.role,
    required this.content,
    required this.timestamp,
  });

  @override
  int get hashCode =>
      id.hashCode ^ role.hashCode ^ content.hashCode ^ timestamp.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SessionMessage &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          role == other.role &&
          content == other.content &&
          timestamp == other.timestamp;
}

/// Session statistics
class SessionStats {
  final int totalSessions;
  final int totalMessages;
  final String activeSessionId;

  const SessionStats({
    required this.totalSessions,
    required this.totalMessages,
    required this.activeSessionId,
  });

  @override
  int get hashCode =>
      totalSessions.hashCode ^
      totalMessages.hashCode ^
      activeSessionId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SessionStats &&
          runtimeType == other.runtimeType &&
          totalSessions == other.totalSessions &&
          totalMessages == other.totalMessages &&
          activeSessionId == other.activeSessionId;
}

/// Session list item (without messages)
class SessionSummary {
  final String id;
  final String title;
  final PlatformInt64 createdAt;
  final PlatformInt64 updatedAt;
  final int messageCount;
  final String lastMessagePreview;

  const SessionSummary({
    required this.id,
    required this.title,
    required this.createdAt,
    required this.updatedAt,
    required this.messageCount,
    required this.lastMessagePreview,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      title.hashCode ^
      createdAt.hashCode ^
      updatedAt.hashCode ^
      messageCount.hashCode ^
      lastMessagePreview.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SessionSummary &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          title == other.title &&
          createdAt == other.createdAt &&
          updatedAt == other.updatedAt &&
          messageCount == other.messageCount &&
          lastMessagePreview == other.lastMessagePreview;
}
