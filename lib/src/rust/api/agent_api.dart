// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'config_api.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'agent_api.freezed.dart';

// These functions are ignored because they are not marked as `pub`: `agent_handle`, `config_state`, `ensure_agent`, `truncate_str`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `ChatMessageDto`, `ConfigState`, `ToolCallDto`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`

/// Initialize the agent runtime: load zeroclaw config from ~/.zeroclaw/config.toml.
/// Returns a status string describing what was loaded.
Future<String> initRuntime() =>
    RustLib.instance.api.crateApiAgentApiInitRuntime();

/// Check if the runtime has a loaded config with an API key
Future<RuntimeStatus> getRuntimeStatus() =>
    RustLib.instance.api.crateApiAgentApiGetRuntimeStatus();

/// Update configuration fields. Invalidates the current agent so the next
/// message will create a fresh agent with the new settings.
Future<String> updateConfig({
  String? provider,
  String? model,
  String? apiKey,
  String? apiBase,
  double? temperature,
}) => RustLib.instance.api.crateApiAgentApiUpdateConfig(
  provider: provider,
  model: model,
  apiKey: apiKey,
  apiBase: apiBase,
  temperature: temperature,
);

/// Persist current config to disk (~/.zeroclaw/config.toml).
/// Reads the existing file, merges relevant fields, and writes back.
Future<String> saveConfigToDisk() =>
    RustLib.instance.api.crateApiAgentApiSaveConfigToDisk();

/// Get the current config values as an AppConfig DTO
Future<AppConfig> getCurrentConfig() =>
    RustLib.instance.api.crateApiAgentApiGetCurrentConfig();

/// Create a new chat session descriptor
ChatSessionInfo createSession() =>
    RustLib.instance.api.crateApiAgentApiCreateSession();

/// Clear the current session (resets agent conversation history)
Future<void> clearSession() =>
    RustLib.instance.api.crateApiAgentApiClearSession();

/// Switch to a different session â€” clears agent history for the new context
Future<void> switchSession({required String sessionId}) =>
    RustLib.instance.api.crateApiAgentApiSwitchSession(sessionId: sessionId);

/// Send a message to the zeroclaw agent and get response events.
/// This calls the real LLM provider and executes tools as needed.
Future<List<AgentEvent>> sendMessage({
  required String sessionId,
  required String message,
}) => RustLib.instance.api.crateApiAgentApiSendMessage(
  sessionId: sessionId,
  message: message,
);

/// Streaming version: sends agent events in real-time through a StreamSink.
///
/// Uses zeroclaw's `Agent::turn_streaming()` which delegates to the internal
/// `run_tool_call_loop` with an `on_delta` channel.  Tool-start / tool-end /
/// thinking events are streamed **as they happen**, not after the full turn
/// completes.
Stream<AgentEvent> sendMessageStream({
  required String sessionId,
  required String message,
}) => RustLib.instance.api.crateApiAgentApiSendMessageStream(
  sessionId: sessionId,
  message: message,
);

/// List available tools dynamically from the agent's registered tool specs.
/// Falls back to a minimal static list if no agent is currently initialized.
///
/// Note: kept as sync (#[frb(sync)]) to match the existing FRB generated binding.
/// Uses `try_lock` to avoid blocking if agent is mid-turn.
List<ToolSpecDto> listTools() =>
    RustLib.instance.api.crateApiAgentApiListTools();

/// Get the workspace directory for a session
Future<String> getSessionWorkspaceDir({required String sessionId}) => RustLib
    .instance
    .api
    .crateApiAgentApiGetSessionWorkspaceDir(sessionId: sessionId);

/// List files in a session's workspace directory
Future<List<SessionFileEntry>> listSessionWorkspaceFiles({
  required String sessionId,
}) => RustLib.instance.api.crateApiAgentApiListSessionWorkspaceFiles(
  sessionId: sessionId,
);

/// Open a file or directory with the system default application
Future<String> openInSystem({required String path}) =>
    RustLib.instance.api.crateApiAgentApiOpenInSystem(path: path);

/// Copy a file from the session workspace to a user-chosen destination.
/// Returns the destination path on success.
Future<String> copyFileTo({required String src, required String dst}) =>
    RustLib.instance.api.crateApiAgentApiCopyFileTo(src: src, dst: dst);

@freezed
sealed class AgentEvent with _$AgentEvent {
  const AgentEvent._();

  /// Agent is thinking / preparing
  const factory AgentEvent.thinking() = AgentEvent_Thinking;

  /// Incremental text token from LLM
  const factory AgentEvent.textDelta({required String text}) =
      AgentEvent_TextDelta;

  /// LLM started calling a tool
  const factory AgentEvent.toolCallStart({
    required String name,
    required String args,
  }) = AgentEvent_ToolCallStart;

  /// Tool call completed
  const factory AgentEvent.toolCallEnd({
    required String name,
    required String result,
    required bool success,
  }) = AgentEvent_ToolCallEnd;

  /// Full message generation complete
  const factory AgentEvent.messageComplete({
    BigInt? inputTokens,
    BigInt? outputTokens,
  }) = AgentEvent_MessageComplete;

  /// Error during processing
  const factory AgentEvent.error({required String message}) = AgentEvent_Error;
}

/// Chat session info
class ChatSessionInfo {
  final String id;
  final String title;
  final PlatformInt64 createdAt;
  final PlatformInt64 updatedAt;
  final int messageCount;

  const ChatSessionInfo({
    required this.id,
    required this.title,
    required this.createdAt,
    required this.updatedAt,
    required this.messageCount,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      title.hashCode ^
      createdAt.hashCode ^
      updatedAt.hashCode ^
      messageCount.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ChatSessionInfo &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          title == other.title &&
          createdAt == other.createdAt &&
          updatedAt == other.updatedAt &&
          messageCount == other.messageCount;
}

/// Runtime status information
class RuntimeStatus {
  final bool initialized;
  final bool hasApiKey;
  final String provider;
  final String model;

  const RuntimeStatus({
    required this.initialized,
    required this.hasApiKey,
    required this.provider,
    required this.model,
  });

  @override
  int get hashCode =>
      initialized.hashCode ^
      hasApiKey.hashCode ^
      provider.hashCode ^
      model.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RuntimeStatus &&
          runtimeType == other.runtimeType &&
          initialized == other.initialized &&
          hasApiKey == other.hasApiKey &&
          provider == other.provider &&
          model == other.model;
}

/// File entry in the session workspace
class SessionFileEntry {
  final String name;
  final String path;
  final bool isDir;
  final BigInt size;

  const SessionFileEntry({
    required this.name,
    required this.path,
    required this.isDir,
    required this.size,
  });

  @override
  int get hashCode =>
      name.hashCode ^ path.hashCode ^ isDir.hashCode ^ size.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SessionFileEntry &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          path == other.path &&
          isDir == other.isDir &&
          size == other.size;
}

/// Tool specification for UI display
class ToolSpecDto {
  final String name;
  final String description;

  const ToolSpecDto({required this.name, required this.description});

  @override
  int get hashCode => name.hashCode ^ description.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ToolSpecDto &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          description == other.description;
}
